		     +--------------------------+
		     |            OS            |
		     | PROJECT 2: USER PROGRAMS |
		     |     DESIGN DOCUMENT      |
		     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Xiaoqi Cao <s9xicaoo@stud.uni-saarland.de>
Wenkai Dai <donydwk@gmail.com>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* width of the command matrix representing the number of arguments*/
#define COMMAND_WIDTH 30

/* length of command matrix representing the max length of every arguments*/
#define COMMAND_LENGTH 128

/* the command matrix*/
static char command[COMMAND_WIDTH][COMMAND_LENGTH];

/* array to store the argument address pushed in stack*/
static char* command_p[COMMAND_WIDTH];


---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?


ALGORITHM
1  parse the command line by ' ' and store args into command matrix
2  get user stack top pointer
3  get all arguments from matrix and push it into stack
4  word-align
5  push 4 bytes with value 0
6  push the arguments address into stack in right order
7  push number of arguments into stack
8  push fake retrun address into stack

argv[] in right order:
I use >> and & operation.
1 right shift address value of argument by 24bit, 16bit, 8bit, 0bit.
2 after each right shift, conjunct it with 0x000000ff
3 shift the result into type char
4 push this char value into stack

i = 0;
while(i < 4) {
	int ct = (int)(argv_p) >> ((4 - i - 1) * 8);
	ct = ct & 0x000000ff;
	char c = (char)ct;
	*--sp = c;
	i++;
}

avoid overflowing the stack page

I limit the size of command matrix, if it is overflowed, the thread will exit.


---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

the strtok_r() store the save_ptr but strtok don't. The string will be consumed by strtok.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

1 avoid to giving kernel extra work to do.
2 protecting the kernel from some inputs which may give kernel bad affect

			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* This structure is used to representing a thread which is corresponding to
   the a sub process which is generated by the parent process(thread).*/
struct sub_thread {
	int pid;							/* process id*/
	int exit_code;						/* the exit_code of this process*/
	struct list_elem s_t_elem;			/* list element for listing*/
};

struct thread
  {
    /* Owned by thread.c. */
    tid_t tid;                          /* Thread identifier. */
    enum thread_status status;          /* Thread state. */
    char name[64];                      /* Name (for debugging purposes). */
    uint8_t *stack;                     /* Saved stack pointer. */
    int priority;                       /* Priority. */
    struct list_elem allelem;           /* List element for all threads list. */

    /* Shared between thread.c and synch.c. */
    struct list_elem elem;              /* List element. */

#ifdef USERPROG
    /* Owned by userprog/process.c. */
    uint32_t *pagedir;                  /* Page directory. */
#endif

    /* Owned by thread.c. */
    unsigned magic;                     /* Detects stack overflow. */

    struct list fd_list;				/* Files held by this process/thread*/

    struct list sub_threads;			/* threads list for child processes*/

    struct thread *pt;					/* pointer to thread representing parent process*/

    bool is_waited_by_parent;			/* flag to indicate a process is waiting by parent or not*/

    struct file *executable_f;			/* the executable file corresponding to process*/

  };

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

/* This structure is used to representing a <fd,file> tuple
   which is owned by specific thread-- in the fd_list of the thread.*/
struct fd_elem {
	uint32_t fd;						/* file descriptor*/
	struct file *f;						/* pointer to file structure*/
	char *file_name;					/* pointer to file name*/
	struct list_elem fdl_elem;			/* list element for listing*/
};

when file is opened, system will generate next value of fd and store it into fd_list of a thread within fd_elem.

The file descriptors is unique through the system.

/* the item of fd_list head, fd_list is the fds held by a thread*/
struct fds_stub {
	struct list *l;
	struct list_elem fds_elem;
};

/* the list of fd_list head, fd_list is the fds held by a thread*/
struct list fds_ll;


/* the item to record the file which will be deleted in future due to a process calls
   the remove system call, but it will not be deleted now due to some process may refer it
   , after all the process release its fd corresponding to the certain file, the file
   this is for implementing the unix file removing mechanism*/
struct removing_file {
	int fd;
	struct thread *t;
	char *file_name;
	struct list_elem r_elem;
};

/* the list of removing file*/
struct list removing_list;



---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

1 validation of esp
2 pop system call number
3 pop args
4 validation the arguments which are pointers
5 put return value into eax

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?



>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

1 try to get thread of child process
2 if pointer of thread of child process is null, it indicates the child process is exited. Return the exit code
  of thread directly.
3 if the pointer of thread of child process is not null, it indicates the child process is not exited.
  if its is_waited_by_parent flag is false or its pt is not the pointer of parent thread, return -1 directly.
4 if child process is not exited and it is not waited now, set the flag is_waited_by_parent to true.
5 then block parent thread (current thread)
6 when child process exits, it sets exit code to the corresponding item in sub_thread list in parent thread and 
  unblock its parent thread.
7 when the parent thread (current thread) is waken, get the exit code of this child process
8 return the exit code.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

/* Get argument as a pointer
   It can be converted into char* or another pointer type.
   It at the same time does validation work to the user pointer*/
void* get_arg_pointer(unsigned int index, void* stack_p)

/* Get argument as an integer */
int get_arg_integer(unsigned int index, void* stack_p)

/* check the validation of pointers passed from user. */
bool check_user_pointer(void* p)

I use check_user_pointer to validate the pointor from user. It validate the user pointer from being NULL,
pointing to kernel VM, or unmapped VM.
from dispatching system call, I use get_arg_pointer and/or get_arg_integer to get corresponding arguments.
whenever to use get_arg_pointer and/or get_arg_integer depends on the concrete system call argument array.

example the create system call

	case SYS_WRITE://9
		if (is_invalid_pt(stack_p, 3)) {
			process_invalid_exit();
		}
		n = get_arg_integer(0, stack_p);
		p = (char *)get_arg_pointer(1, stack_p);
		m = get_arg_integer(2, stack_p);
		int retval = write(n,p,m);
		f->eax = retval;
		break;

I get n, p and m from stack and in get_arg_pointer function I validate the pointers.

if the pointer is somehow invalid, I do the things below:
1 	close all the files opened
2   remove items form removing list if it has
3   set all its child processes to orphaned

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

1 I added a semaphore with init value 0.
2 After thread_create(), do sema_down, it cause the parent thread wait for the child's loading.
3 When load complete, no matter it success or fail, up semaphore and let parent go on to run.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

Every time, a process is exited, it will release all the resources it has (see exit system call).


---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

The intr_frame->esp is pointing to the top of the user stack.
Every parameter is 4 types long no matter it is int or a pointer.
According to certain system call, I move the pointer every time by 4 types and read value
If it is a pointer, I validate it.
When system call returns and it has return value, I give the value to intr_frame-eax

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

advantages:
1 Global fd number, it will not duplicated.
2 Every thread has its own fd list (fd_list) and each fd has its file structure 
  pointer stored in a structure named fd_elem,
  it is easy to get file structure pointer from fd.
3 I have a list of fd_list head pointer which is used if user want to get thread by fd,
  it avoids to looping all threads (some threads may have not opened any file), more efficient.
disadvantages:
1 need more space to store extra information of fd, fd_list and list of fd_list.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

It will give advantage when user want to associate a process with more than one thread, in this case,
the user process id and thread id is not one-to-one. The traditional mapping does not work here.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?
   normal, too long
>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?
   yes
>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?
   may give a lecture of pintos is good for understanding how to implement an OS.
>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?
   No.
>> Any other comments?
   No.